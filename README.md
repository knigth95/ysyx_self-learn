### [个人学习记录](https://docs.qq.com/sheet/DSW1YcE1aaHhGaUVZ?tab=BB08J2)


2.29
#### ex8
- 因为字符串数组没有以’\0’结尾（长度只有11位），用printf打印输出时因为没有\0而不知道结尾在哪，出现乱码；但这里没报错，我猜是当前版本的gcc编译器对其做了处理，也许换个编译器就会报错了。
- 不同CPU上整数所占的不同大小
	- 决定一个芯片多少位，是**由这个芯片一次能处理多少位数据决定的，等于片内寄存器的宽度，同时可以看成是数据总线的宽度。几乎所有的芯片位数都等于数据总线宽度
	- int类型的大小是**由limits.h文件中INT_MIN和INT_MAX两个宏定义**来决定的，而limits.h文件在编译器库文件中可以找到
		- 16位系统中，int型为16位大小，两字节
		- 32位系统中，int型为32位大小，四字节
		- 64位系统中，int型为32位大小，四字节
	- 除了int类型，还有一个类型在不同平台中有不同的表现，那就是long型
		- 16位系统中，long型为32位大小，4字节
		- 32位系统中，long型为32位大小，4字节
		- 64位系统中，long型为64位大小，8字节
	- 指针大小
		- 指针本质上是变量，它的值是内存中的地址，既然需要通过指针能够访问当内存当中所有的数据，那么这个**指针类型的宽度至少要大于等于地址总线的宽度。
		- 打个比方一个芯片的地址总线是32位，那么内存地址的范围就是0~4G，那么这个指针类型的宽度至少需要32位，才能保证访问到内存中每个字节。
		- 早期的8086而言，这是16位芯片，但是它的地址总线却扩展到了20位，同时因为数据对齐的原因，它的指针大小应该是16+16位=32位，但是出于效率上的优化，8086提供了**远指针、近指针，在访问本段内的地址时，采用16位指针，如果有段地址跳转，就使用32位的指针。
		- **需要特别注意的是，在64位系统中地址大小为4字节的情况下，并非一定是芯片的地址总线是32位，很可能是CPU运行在只使用部分地址总线的模式下，又或者是使用32位兼容的编译器所致，这一部分较为复杂。
